# Autogenerated using ProtoBuf.jl v1.0.14 on 2023-10-06T23:54:27.327
# original file: /home/ablambe/toolpath/ONNXNaiveNASflux.jl/pb_scratch/onnx-data.proto3 (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"SequenceProto.DataType", var"OptionalProto.DataType", MapProto, OptionalProto
export SequenceProto

# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractMapProto" end
abstract type var"##AbstractOptionalProto" end
abstract type var"##AbstractSequenceProto" end


@enumx var"SequenceProto.DataType" UNDEFINED=0 TENSOR=1 SPARSE_TENSOR=2 SEQUENCE=3 MAP=4 OPTIONAL=5

@enumx var"OptionalProto.DataType" UNDEFINED=0 TENSOR=1 SPARSE_TENSOR=2 SEQUENCE=3 MAP=4 OPTIONAL=5

struct MapProto{T1<:Union{Nothing,var"##AbstractSequenceProto"}} <: var"##AbstractMapProto"
    name::String
    key_type::Int32
    keys::Vector{Int64}
    string_keys::Vector{Vector{UInt8}}
    values::T1
end
MapProto(;name = "", key_type = zero(Int32), keys = Vector{Int64}(), string_keys = Vector{Vector{UInt8}}(), values = nothing) = MapProto(name, key_type, keys, string_keys, values)
PB.default_values(::Type{MapProto}) = (;name = "", key_type = zero(Int32), keys = Vector{Int64}(), string_keys = Vector{Vector{UInt8}}(), values = nothing)
PB.field_numbers(::Type{MapProto}) = (;name = 1, key_type = 2, keys = 3, string_keys = 4, values = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MapProto})
    name = ""
    key_type = zero(Int32)
    keys = PB.BufferedVector{Int64}()
    string_keys = PB.BufferedVector{Vector{UInt8}}()
    values = Ref{Union{Nothing,SequenceProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            key_type = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, wire_type, keys)
        elseif field_number == 4
            PB.decode!(d, string_keys)
        elseif field_number == 5
            PB.decode!(d, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return MapProto(name, key_type, keys[], string_keys[], values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MapProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.key_type != zero(Int32) && PB.encode(e, 2, x.key_type)
    !isempty(x.keys) && PB.encode(e, 3, x.keys)
    !isempty(x.string_keys) && PB.encode(e, 4, x.string_keys)
    !isnothing(x.values) && PB.encode(e, 5, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MapProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.key_type != zero(Int32) && (encoded_size += PB._encoded_size(x.key_type, 2))
    !isempty(x.keys) && (encoded_size += PB._encoded_size(x.keys, 3))
    !isempty(x.string_keys) && (encoded_size += PB._encoded_size(x.string_keys, 4))
    !isnothing(x.values) && (encoded_size += PB._encoded_size(x.values, 5))
    return encoded_size
end

struct OptionalProto{T1<:Union{Nothing,var"##AbstractSequenceProto"}} <: var"##AbstractOptionalProto"
    name::String
    elem_type::Int32
    tensor_value::Union{Nothing,TensorProto}
    sparse_tensor_value::Union{Nothing,SparseTensorProto}
    sequence_value::T1
    map_value::Union{Nothing,MapProto}
    optional_value::Union{Nothing,OptionalProto}
end
OptionalProto(;name = "", elem_type = zero(Int32), tensor_value = nothing, sparse_tensor_value = nothing, sequence_value = nothing, map_value = nothing, optional_value = nothing) = OptionalProto(name, elem_type, tensor_value, sparse_tensor_value, sequence_value, map_value, optional_value)
PB.default_values(::Type{OptionalProto}) = (;name = "", elem_type = zero(Int32), tensor_value = nothing, sparse_tensor_value = nothing, sequence_value = nothing, map_value = nothing, optional_value = nothing)
PB.field_numbers(::Type{OptionalProto}) = (;name = 1, elem_type = 2, tensor_value = 3, sparse_tensor_value = 4, sequence_value = 5, map_value = 6, optional_value = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OptionalProto})
    name = ""
    elem_type = zero(Int32)
    tensor_value = Ref{Union{Nothing,TensorProto}}(nothing)
    sparse_tensor_value = Ref{Union{Nothing,SparseTensorProto}}(nothing)
    sequence_value = Ref{Union{Nothing,SequenceProto}}(nothing)
    map_value = Ref{Union{Nothing,MapProto}}(nothing)
    optional_value = Ref{Union{Nothing,OptionalProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            elem_type = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, tensor_value)
        elseif field_number == 4
            PB.decode!(d, sparse_tensor_value)
        elseif field_number == 5
            PB.decode!(d, sequence_value)
        elseif field_number == 6
            PB.decode!(d, map_value)
        elseif field_number == 7
            PB.decode!(d, optional_value)
        else
            PB.skip(d, wire_type)
        end
    end
    return OptionalProto(name, elem_type, tensor_value[], sparse_tensor_value[], sequence_value[], map_value[], optional_value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OptionalProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.elem_type != zero(Int32) && PB.encode(e, 2, x.elem_type)
    !isnothing(x.tensor_value) && PB.encode(e, 3, x.tensor_value)
    !isnothing(x.sparse_tensor_value) && PB.encode(e, 4, x.sparse_tensor_value)
    !isnothing(x.sequence_value) && PB.encode(e, 5, x.sequence_value)
    !isnothing(x.map_value) && PB.encode(e, 6, x.map_value)
    !isnothing(x.optional_value) && PB.encode(e, 7, x.optional_value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OptionalProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.elem_type != zero(Int32) && (encoded_size += PB._encoded_size(x.elem_type, 2))
    !isnothing(x.tensor_value) && (encoded_size += PB._encoded_size(x.tensor_value, 3))
    !isnothing(x.sparse_tensor_value) && (encoded_size += PB._encoded_size(x.sparse_tensor_value, 4))
    !isnothing(x.sequence_value) && (encoded_size += PB._encoded_size(x.sequence_value, 5))
    !isnothing(x.map_value) && (encoded_size += PB._encoded_size(x.map_value, 6))
    !isnothing(x.optional_value) && (encoded_size += PB._encoded_size(x.optional_value, 7))
    return encoded_size
end

struct SequenceProto <: var"##AbstractSequenceProto"
    name::String
    elem_type::Int32
    tensor_values::Vector{TensorProto}
    sparse_tensor_values::Vector{SparseTensorProto}
    sequence_values::Vector{<:SequenceProto}
    map_values::Vector{<:MapProto}
    optional_values::Vector{<:OptionalProto}
end
SequenceProto(;name = "", elem_type = zero(Int32), tensor_values = Vector{TensorProto}(), sparse_tensor_values = Vector{SparseTensorProto}(), sequence_values = Vector{SequenceProto}(), map_values = Vector{MapProto}(), optional_values = Vector{OptionalProto}()) = SequenceProto(name, elem_type, tensor_values, sparse_tensor_values, sequence_values, map_values, optional_values)
PB.default_values(::Type{SequenceProto}) = (;name = "", elem_type = zero(Int32), tensor_values = Vector{TensorProto}(), sparse_tensor_values = Vector{SparseTensorProto}(), sequence_values = Vector{SequenceProto}(), map_values = Vector{MapProto}(), optional_values = Vector{OptionalProto}())
PB.field_numbers(::Type{SequenceProto}) = (;name = 1, elem_type = 2, tensor_values = 3, sparse_tensor_values = 4, sequence_values = 5, map_values = 6, optional_values = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SequenceProto})
    name = ""
    elem_type = zero(Int32)
    tensor_values = PB.BufferedVector{TensorProto}()
    sparse_tensor_values = PB.BufferedVector{SparseTensorProto}()
    sequence_values = PB.BufferedVector{SequenceProto}()
    map_values = PB.BufferedVector{MapProto}()
    optional_values = PB.BufferedVector{OptionalProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            elem_type = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, tensor_values)
        elseif field_number == 4
            PB.decode!(d, sparse_tensor_values)
        elseif field_number == 5
            PB.decode!(d, sequence_values)
        elseif field_number == 6
            PB.decode!(d, map_values)
        elseif field_number == 7
            PB.decode!(d, optional_values)
        else
            PB.skip(d, wire_type)
        end
    end
    return SequenceProto(name, elem_type, tensor_values[], sparse_tensor_values[], sequence_values[], map_values[], optional_values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SequenceProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.elem_type != zero(Int32) && PB.encode(e, 2, x.elem_type)
    !isempty(x.tensor_values) && PB.encode(e, 3, x.tensor_values)
    !isempty(x.sparse_tensor_values) && PB.encode(e, 4, x.sparse_tensor_values)
    !isempty(x.sequence_values) && PB.encode(e, 5, x.sequence_values)
    !isempty(x.map_values) && PB.encode(e, 6, x.map_values)
    !isempty(x.optional_values) && PB.encode(e, 7, x.optional_values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SequenceProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.elem_type != zero(Int32) && (encoded_size += PB._encoded_size(x.elem_type, 2))
    !isempty(x.tensor_values) && (encoded_size += PB._encoded_size(x.tensor_values, 3))
    !isempty(x.sparse_tensor_values) && (encoded_size += PB._encoded_size(x.sparse_tensor_values, 4))
    !isempty(x.sequence_values) && (encoded_size += PB._encoded_size(x.sequence_values, 5))
    !isempty(x.map_values) && (encoded_size += PB._encoded_size(x.map_values, 6))
    !isempty(x.optional_values) && (encoded_size += PB._encoded_size(x.optional_values, 7))
    return encoded_size
end
